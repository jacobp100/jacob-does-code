<!DOCTYPE HTML><html lang="en"><head><title>A Primer in ReasonML</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><script>document.documentElement.style.setProperty("--b",1/(window.devicePixelRatio||1)+"px");</script><style>@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:normal;font-named-instance:"Regular";src:url(/71cddff5.woff2);font-display:fallback}@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:italic;font-named-instance:"Regular";src:url(/510063a2.woff2);font-display:fallback}*,::after,::before{box-sizing:border-box}*{font-weight:var(--c)}@supports (font-variation-settings:"wght" 400){*{font-weight:inherit;font-variation-settings:"wght" var(--c)}}:root{--d:#f97f51;--e:#fc427b;--f:#0652dd;--g:#2771f9;--h:var(--f);--i:#a3cb38;--j:#ed4c67;--a:currentColor;--k:black;--l:white;--m:12px;--n:12px}body{margin:var(--m) var(--n) 64px;font:18px/26px Inter,system-ui,-apple-system,sans-serif;color:var(--k);background:var(--l)}a{color:var(--a, currentColor);text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.a{display:flex;padding-top:12px;margin:-12px calc(-1*var(--n)) 48px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}.a::after,.a::before{display:block;content:"";padding-right:var(--n)}.b,.c{flex:none;--c:700}.b{display:block;font-size:24px;line-height:18px;letter-spacing:-1px;text-transform:lowercase;border-top:4px solid currentColor;padding:6px 4px 0 0}a.b{color:currentColor;text-decoration:none}.c{margin:0 0 0 24px;font-size:6px;line-height:10px;letter-spacing:1px;text-transform:uppercase;width:0}.d{margin-left:auto}.e{flex:none;display:block;margin:10px 24px 0 0;font-size:14px;--c:400;line-height:18px}.e:last-child{margin-right:0}@media (prefers-color-scheme:dark){:root{--h:var(--g);--k:white;--l:black}}@media (min-width:768px){:root{--n:64px}}@media (min-width:1024px){:root{--n:128px}}:root{--n:max(12px, (100vw - var(--o)) / 2);--o:800px;--a:var(--j)}h1,h2{font-weight:700}h1{margin:48px 0 32px;font-size:36px;line-height:52px;letter-spacing:-.8px}h2{font-size:26px;line-height:34px;letter-spacing:-.3px}blockquote,h3{font-size:22px;line-height:32px}h2,h3{margin:42px 0 18px}h3{letter-spacing:-.18px}p{margin:18px 0}h3,strong{font-weight:600}ol,ul{margin:24px 0;padding-left:32px;margin-left:calc(-32*min(max(var(--n) - 32px,0px),1px))}li{position:relative;margin:2px 0;list-style:none}li::before{position:absolute;content:var(--p, "ðŸ‘‰");right:calc(100% + 12px)}li[data-bullet]{--p:attr(data-bullet)}blockquote{margin:32px 24px 32px 48px;font-weight:300;font-style:italic}table{margin:24px;border-collapse:separate;border-spacing:12px 0}thead th{border-bottom:var(--b) solid;--c:600;text-align:left}code{font-size:.9em;font-family:monospace;padding:0 3px;background-color:#f4f4f4;border:1px solid #eee;border-radius:6px}pre code{display:block;width:100vw;margin:48px calc(-1*var(--n));padding:18px var(--n);background-color:#fafafa;border:1px solid #f4f4f4;border-width:1px 0;border-radius:0;overflow-x:scroll}.f,blockquote{color:#9e9e9e}@media (prefers-color-scheme:dark){code{background-color:#111;border-color:#222}pre code{background-color:#080808;border-color:#111}}@media (max-width:767px){a,p>code{word-break:break-all}}</style><link href="/67634ae9.css" rel="stylesheet"/></head><body><div class="a"><a href="/" class="b">Jacob<br/>does<br/>code</a><div class="c">Apps</div><a href="/pocket-jam" class="e">Pocket Jam</a><a href="/piano-tabs" class="e">Piano Tabs</a><a href="/technicalc" class="e">TechniCalc</a><a href="/freebies" class="e">Freebies</a><div class="c d">Developement</div><a href="/blog" class="e">Blog</a><a href="https://github.com/jacobp100" class="e">Github</a></div><div><h1>A Primer in ReasonML</h1><p>If youâ€™ve used Reason a little bit, you might have seen <code>string_of_int</code>, <code>string_of_float</code>, or if youâ€™re using Belt, <code>Float.toString</code>.</p><p>So the question is â€” why is this necessary? A lot of languages let you do <code>toString</code> without saying the type youâ€™re converting from.</p><p>A lot of languages support something called function overloading. Take C# for example,</p><pre><code class="hljs language-c#"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> { <span class="hljs-comment">/*...*/</span> }
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> x</span>)</span> { <span class="hljs-comment">/*...*/</span> }</code></pre><p>In JavaScript, you can get something to the same effect by using <code>typeof</code> checks.</p><p>Most languages, too, support essentially the same thing through object inheritance too. You can have a class <code>Pet</code> with a <code>toString</code> method on it, then make subclasses <code>Dog</code> and <code>Cat</code> which each have their own <code>toString</code> methods.</p><p>Reason doesnâ€™t support the first kind of overloading. Functions can only be defined once, and you canâ€™t do <code>typeof</code> checks on what is passed in.</p><p>Reason does technically have some concept of classes, but they are rarely used. Itâ€™s best to just not use them. Itâ€™s because of these reasons there are multiple kinds of <code>+</code> operator â€” including <code>+.</code> for floats, <code>++</code> for strings.</p><p>This might initially seem like a significant limitation, but the omission of these features is intentional: these features always have edge cases in any language that includes them.</p><h2>Modules</h2><p>The most unique part of Reason is its module system. They are much more powerful than classes â€” both for the user, the type checker and the compiler.</p><p>Usually, you will make your modules as isolated as possible, and group all the functionality in the module â€” not far off what your average class looks like.</p><p>The convention is to have a type <code>t</code> that encompasses all the data a class would have. You also normally have a <code>make</code> function to act as a constructor and/or an <code>empty</code> variable if that makes sense for your module. For example,</p><pre><code class="hljs language-reasonml"><span class="hljs-keyword">module</span> Person = {
  <span class="hljs-keyword">type</span> t = {name: <span class="hljs-built_in">string</span>};

  <span class="hljs-keyword">let</span> make =<span class="hljs-function"> <span class="hljs-params">name</span> =></span> {name: name};

  <span class="hljs-keyword">let</span> toString =<span class="hljs-function"> <span class="hljs-params">person</span> =></span> <span class="hljs-string">"Person :"</span><span class="hljs-operator"> ++ </span>person.name;
};

<span class="hljs-keyword">let</span> person = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>make(<span class="hljs-string">"Bob"</span>);
<span class="hljs-keyword">let</span> personString = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">person</span>)</span>;
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>log(personString);

<span class="hljs-comment">/* Or */</span>
<span class="hljs-keyword">let</span> personString = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span>(make("Bob")->toString)</span>;</code></pre><p>I said before this isnâ€™t too far from what an average class looks like. But there is one crucial difference.</p><p>In OOP, your data and your functions are forcibly coupled together. Here, however, the grouping is just for the programmer â€” there is nothing actually forcing the type and the two functions together.</p><p>OOP tends to suffer from data not being strictly hierarchical. By not coupling the data and functions means that when your data isnâ€™t hierarchical, you have much better tools to organise your code â€” although thatâ€™s another blog post.</p><h2>Bonus Time</h2><p>As a last bonus, something youâ€™ll see in Belt is defining operators in a module â€” and this is something you can do too!</p><pre><code class="hljs language-reasonml"><span class="hljs-keyword">module</span> Fraction = {
  <span class="hljs-keyword">type</span> t = {
    num: <span class="hljs-built_in">int</span>,
    den: <span class="hljs-built_in">int</span>,
  };

  <span class="hljs-keyword">let</span> make =<span class="hljs-function"> (<span class="hljs-params">num</span>, <span class="hljs-params">den</span>) =></span> {num, den};

  <span class="hljs-keyword">let</span><span class="hljs-function"> (+) = (<span class="hljs-params">a</span>, <span class="hljs-params">b</span>) =></span> {
    num: a.num<span class="hljs-operator"> * </span>b.den + a.den<span class="hljs-operator"> * </span>b.num,
    den: a.den<span class="hljs-operator"> * </span>b.den,
  };
};

<span class="hljs-keyword">let</span> fractionSum = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Fraction</span>.</span>(make(1, 2) + make(1, 3))</span>;
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>log(fractionSum);</code></pre><p>This is a bit like marmite â€” some people love it, some hate it. It really depends on your project how much youâ€™ll make use of it â€” if at all.</p></div><span class="f">Published on <time dateTime="2020-04-08T00:00:00.000Z">8th April 2020</time></span></body></html>
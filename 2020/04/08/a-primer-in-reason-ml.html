<!DOCTYPE html><html lang="en"><head><title>A Primer in ReasonML</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><script>document.documentElement.style.setProperty("--b",1/(window.devicePixelRatio||1)+"px");</script><style>@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:normal;font-named-instance:"Regular";src:url(/res/541fae2e.woff2);font-display:fallback}@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:italic;font-named-instance:"Regular";src:url(/res/1517082.woff2);font-display:fallback}*,::after,::before{box-sizing:border-box}*{font-weight:var(--c)}@supports (font-variation-settings:"wght" 400){*{font-weight:inherit;font-variation-settings:"wght" var(--c)}}:root{--d:#f97f51;--e:#fc427b;--f:#0652dd;--g:#2771f9;--h:var(--f);--i:#a3cb38;--j:#ed4c67;--a:var(--k);--k:black;--l:white;--m:12px;--n:12px}::selection{background:var(--a);color:#fff}body{margin:var(--m) var(--n) 64px;font:18px/26px Inter,system-ui,-apple-system,sans-serif;color:var(--k);background:var(--l);line-height:26px}a{color:var(--a);text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.a{display:flex;padding-top:12px;margin:-12px calc(-1*var(--n)) 48px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}.a::after,.a::before{display:block;content:"";padding-right:var(--n)}.b,.c{flex:none;--c:700}.b{display:block;font-size:24px;line-height:18px;letter-spacing:-1px;text-transform:lowercase;border-top:4px solid;padding:6px 4px 0 0}a.b{color:currentColor;text-decoration:none}.c{margin:0 0 0 24px;font-size:6px;line-height:10px;letter-spacing:1px;text-transform:uppercase;width:0}.e{margin-left:auto}.d{flex:none;display:block;margin:10px 24px 0 0;font-size:14px;--c:400;line-height:18px}.d:last-child{margin-right:0}@media (prefers-color-scheme:dark){:root{--h:var(--g);--k:white;--l:black}}@media (min-width:768px){:root{--n:64px}}@media (min-width:1024px){:root{--n:128px}}:root{--n:max(12px, (100vw - var(--o)) / 2);--o:800px;--a:var(--j)}h1{margin:48px 0 32px;font-size:36px;line-height:48px;letter-spacing:-.8px}h2,h3{margin:42px 0 18px}h1,h2{font-weight:700}h2{font-size:26px;line-height:34px;letter-spacing:-.3px}h3{font-size:22px;line-height:30px;letter-spacing:-.18px}p{margin:18px 0}a,p>code{word-break:break-all}h3,strong{font-weight:600}ol,ul{margin:24px 0;padding-left:32px;margin-left:calc(-32*min(max(var(--n) - 32px,0px),1px))}li{position:relative;margin:2px 0;list-style:none}li::before{position:absolute;content:var(--p, "ðŸ‘‰");right:calc(100% + 12px)}li[data-bullet]{--p:attr(data-bullet)}blockquote{margin:32px 24px 32px 48px;font-size:22px;line-height:32px;font-weight:300;font-style:italic}table{margin:24px;border-collapse:separate;border-spacing:12px 0}thead th{border-bottom:var(--b) solid;--c:600;text-align:left}code{font-size:.9em;font-family:monospace;padding:0 3px;background-color:#f4f4f4;border:1px solid #eee;border-radius:6px}pre code{display:block;width:100vw;margin:48px calc(-1*var(--n));padding:18px var(--n);background-color:#fafafa;border:1px solid #f4f4f4;border-width:1px 0;border-radius:0;overflow-x:scroll}video{display:block;max-width:100%;margin:32px auto}iframe{width:calc(var(--q)*1);height:calc(var(--q)*.66);border:1px solid rgba(0,0,0,.1);--q:calc(100vw - 2 * var(--n))}.f,blockquote{color:#9e9e9e}@media (min-width:768px){a,p>code{word-break:initial}}@media (prefers-color-scheme:dark){code{background-color:#111;border-color:#222}pre code{background-color:#080808;border-color:#111}}.-k,.-t{color:#a0a1a7;font-style:italic}.-l,.-u,.-v{color:#a626a4}.-h,.-w,.-x,.-y,.-z{color:#e45649}.-A{color:#0184bb}.-B,.-C,.-D,.-E,.-j{color:#50a14f}.-F,.-G .-m{color:#c18401}.-H,.-I,.-J,.-K,.-L,.-M,.-i,.-o{color:#986801}.-N,.-O,.-P,.-Q,.-R,.-m{color:#4078f2}.-e{font-style:italic}.-S{font-weight:700}.-P{text-decoration:underline}@media (prefers-color-scheme:dark){.-k,.-t{color:#5c6370;font-style:italic}.-l,.-u,.-v{color:#c678dd}.-h,.-w,.-x,.-y,.-z{color:#e06c75}.-A{color:#56b6c2}.-B,.-C,.-D,.-E,.-j{color:#98c379}.-F,.-G .-m{color:#e6c07b}.-H,.-I,.-J,.-K,.-L,.-M,.-i,.-o{color:#d19a66}.-N,.-O,.-P,.-Q,.-R,.-m{color:#61aeee}.-e{font-style:italic}.-S{font-weight:700}.-P{text-decoration:underline}}</style></head><body><div class="a"><a href="/" class="b">Jacob<br/>does<br/>code</a><div class="c">Apps</div><a href="/pocket-jam" class="d">Pocket Jam</a><a href="/piano-tabs" class="d">Piano Tabs</a><a href="/technicalc" class="d">TechniCalc</a><a href="/freebies" class="d">Freebies</a><div class="c e">Developement</div><a href="/blog" class="d">Blog</a><a href="https://github.com/jacobp100" class="d">Github</a></div><h1>A Primer in ReasonML</h1><p>If youâ€™ve used Reason a little bit, you might have seen <code>string_of_int</code>, <code>string_of_float</code>, or if youâ€™re using Belt, <code>Float.toString</code>.</p><p>So the question is â€” why is this necessary? A lot of languages let you do <code>toString</code> without saying the type youâ€™re converting from.</p><p>A lot of languages support something called function overloading. Take C# for example,</p><pre><code><span class="-U"><span class="-F">string</span> <span class="-m">ToString</span>(<span class="-T"><span class="-F">int</span> x</span>)</span> { <span class="-k">/*...*/</span> }
<span class="-U"><span class="-F">string</span> <span class="-m">ToString</span>(<span class="-T"><span class="-F">float</span> x</span>)</span> { <span class="-k">/*...*/</span> }
</code></pre><p>In JavaScript, you can get something to the same effect by using <code>typeof</code> checks.</p><p>Most languages, too, support essentially the same thing through object inheritance too. You can have a class <code>Pet</code> with a <code>toString</code> method on it, then make subclasses <code>Dog</code> and <code>Cat</code> which each have their own <code>toString</code> methods.</p><p>Reason doesnâ€™t support the first kind of overloading. Functions can only be defined once, and you canâ€™t do <code>typeof</code> checks on what is passed in.</p><p>Reason does technically have some concept of classes, but they are rarely used. Itâ€™s best to just not use them.
Itâ€™s because of these reasons there are multiple kinds of <code>+</code> operator â€” including <code>+.</code> for floats, <code>++</code> for strings.</p><p>This might initially seem like a significant limitation, but the omission of these features is intentional: these features always have edge cases in any language that includes them.</p><h2>Modules</h2><p>The most unique part of Reason is its module system. They are much more powerful than classes â€” both for the user, the type checker and the compiler.</p><p>Usually, you will make your modules as isolated as possible, and group all the functionality in the module â€” not far off what your average class looks like.</p><p>The convention is to have a type <code>t</code> that encompasses all the data a class would have. You also normally have a <code>make</code> function to act as a constructor and/or an <code>empty</code> variable if that makes sense for your module. For example,</p><pre><code><span class="-l">module</span> Person = {
  <span class="-l">type</span> t = {name: <span class="-F">string</span>};

  <span class="-l">let</span> make =<span class="-U"> <span class="-T">name</span> =&gt;</span> {name: name};

  <span class="-l">let</span> toString =<span class="-U"> <span class="-T">person</span> =&gt;</span> <span class="-j">&quot;Person :&quot;</span><span class="-V"> ++ </span>person.name;
};

<span class="-l">let</span> person = <span class="-W"><span class="-X"><span class="-Y">Person</span>.</span></span>make(<span class="-j">&quot;Bob&quot;</span>);
<span class="-l">let</span> personString = <span class="-W"><span class="-X"><span class="-Y">Person</span>.</span></span><span class="-l">to</span><span class="-Z">String(<span class="-T">person</span>)</span>;
<span class="-W"><span class="-X"><span class="-Y">Js</span>.</span></span>log(personString);

<span class="-k">/* Or */</span>
<span class="-l">let</span> personString = <span class="-W"><span class="-X"><span class="-Y">Person</span>.</span>(make(&quot;Bob&quot;)-&gt;toString)</span>;
</code></pre><p>I said before this isnâ€™t too far from what an average class looks like. But there is one crucial difference.</p><p>In OOP, your data and your functions are forcibly coupled together. Here, however, the grouping is just for the programmer â€” there is nothing actually forcing the type and the two functions together.</p><p>OOP tends to suffer from data not being strictly hierarchical. By not coupling the data and functions means that when your data isnâ€™t hierarchical, you have much better tools to organise your code â€” although thatâ€™s another blog post.</p><h2>Bonus Time</h2><p>As a last bonus, something youâ€™ll see in Belt is defining operators in a module â€” and this is something you can do too!</p><pre><code><span class="-l">module</span> Fraction = {
  <span class="-l">type</span> t = {
    num: <span class="-F">int</span>,
    den: <span class="-F">int</span>,
  };

  <span class="-l">let</span> make =<span class="-U"> (<span class="-T">num</span>, <span class="-T">den</span>) =&gt;</span> {num, den};

  <span class="-l">let</span><span class="-U"> (+) = (<span class="-T">a</span>, <span class="-T">b</span>) =&gt;</span> {
    num: a.num<span class="-V"> * </span>b.den + a.den<span class="-V"> * </span>b.num,
    den: a.den<span class="-V"> * </span>b.den,
  };
};

<span class="-l">let</span> fractionSum = <span class="-W"><span class="-X"><span class="-Y">Fraction</span>.</span>(make(1, 2) + make(1, 3))</span>;
<span class="-W"><span class="-X"><span class="-Y">Js</span>.</span></span>log(fractionSum);
</code></pre><p>This is a bit like marmite â€” some people love it, some hate it. It really depends on your project how much youâ€™ll make use of it â€” if at all.</p><span class="f">Published on <time dateTime="2020-04-08T00:00:00.000Z">8th April 2020</time></span></body></html>
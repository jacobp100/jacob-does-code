<!DOCTYPE HTML><html lang="en"><head><title>Polymorphic Variants in ReasonML</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><script>document.documentElement.style.setProperty("--b",1/(window.devicePixelRatio||1)+"px");</script><style>@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:normal;font-named-instance:"Regular";src:url(/res/541fae2e.woff2);font-display:fallback}@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:italic;font-named-instance:"Regular";src:url(/res/1517082.woff2);font-display:fallback}*,::after,::before{box-sizing:border-box}*{font-weight:var(--c)}@supports (font-variation-settings:"wght" 400){*{font-weight:inherit;font-variation-settings:"wght" var(--c)}}:root{--d:#f97f51;--e:#fc427b;--f:#0652dd;--g:#2771f9;--h:var(--f);--i:#a3cb38;--j:#ed4c67;--a:var(--k);--k:black;--l:white;--m:12px;--n:12px}::selection{background:var(--a);color:#fff}body{margin:var(--m) var(--n) 64px;font:18px/26px Inter,system-ui,-apple-system,sans-serif;color:var(--k);background:var(--l);line-height:26px}a{color:var(--a);text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.a{display:flex;padding-top:12px;margin:-12px calc(-1*var(--n)) 48px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}.a::after,.a::before{display:block;content:"";padding-right:var(--n)}.b,.c{flex:none;--c:700}.b{display:block;font-size:24px;line-height:18px;letter-spacing:-1px;text-transform:lowercase;border-top:4px solid;padding:6px 4px 0 0}a.b{color:currentColor;text-decoration:none}.c{margin:0 0 0 24px;font-size:6px;line-height:10px;letter-spacing:1px;text-transform:uppercase;width:0}.d{margin-left:auto}.e{flex:none;display:block;margin:10px 24px 0 0;font-size:14px;--c:400;line-height:18px}.e:last-child{margin-right:0}@media (prefers-color-scheme:dark){:root{--h:var(--g);--k:white;--l:black}}@media (min-width:768px){:root{--n:64px}}@media (min-width:1024px){:root{--n:128px}}:root{--n:max(12px, (100vw - var(--o)) / 2);--o:800px;--a:var(--j)}h1{margin:48px 0 32px;font-size:36px;line-height:48px;letter-spacing:-.8px}h2,h3{margin:42px 0 18px}h1,h2{font-weight:700}h2{font-size:26px;line-height:34px;letter-spacing:-.3px}h3{font-size:22px;line-height:30px;letter-spacing:-.18px}p{margin:18px 0}a,p>code{word-break:break-all}h3,strong{font-weight:600}ol,ul{margin:24px 0;padding-left:32px;margin-left:calc(-32*min(max(var(--n) - 32px,0px),1px))}li{position:relative;margin:2px 0;list-style:none}li::before{position:absolute;content:var(--p, "ðŸ‘‰");right:calc(100% + 12px)}li[data-bullet]{--p:attr(data-bullet)}blockquote{margin:32px 24px 32px 48px;font-size:22px;line-height:32px;font-weight:300;font-style:italic}table{margin:24px;border-collapse:separate;border-spacing:12px 0}thead th{border-bottom:var(--b) solid;--c:600;text-align:left}code{font-size:.9em;font-family:monospace;padding:0 3px;background-color:#f4f4f4;border:1px solid #eee;border-radius:6px}pre code{display:block;width:100vw;margin:48px calc(-1*var(--n));padding:18px var(--n);background-color:#fafafa;border:1px solid #f4f4f4;border-width:1px 0;border-radius:0;overflow-x:scroll}.f,blockquote{color:#9e9e9e}@media (min-width:768px){a,p>code{word-break:initial}}@media (prefers-color-scheme:dark){code{background-color:#111;border-color:#222}pre code{background-color:#080808;border-color:#111}}</style><link href="/res/25e299e9.css" rel="stylesheet"/></head><body><div class="a"><a href="/" class="b">Jacob<br/>does<br/>code</a><div class="c">Apps</div><a href="/pocket-jam" class="e">Pocket Jam</a><a href="/piano-tabs" class="e">Piano Tabs</a><a href="/technicalc" class="e">TechniCalc</a><a href="/freebies" class="e">Freebies</a><div class="c d">Developement</div><a href="/blog" class="e">Blog</a><a href="https://github.com/jacobp100" class="e">Github</a></div><h1>Polymorphic Variants in ReasonML</h1><p>Polymorphic variants are one of the more unique features of OCaml (or ReasonML if you prefer). These are actually one of the things that arenâ€™t documented ReasonML site, but they can be really useful nonetheless.</p><p>At their simplest, they work exactly the same as regular variants. The first difference is that these variants begin with a <code>`</code> character. They can also be used without a type definition. Letâ€™s find the index of a pair of brackets in a list of characters.</p><pre><code class="-M -Z"><span class="-h">let</span> firstBracketPair =<span class="-T"> <span class="-W">inputChars</span> =></span> {
  <span class="-h">let</span> <span class="-h">rec</span> iter =<span class="-T"> (<span class="-W">currentState</span>, <span class="-W">chars</span>, <span class="-W">currentIndex</span>) =></span>
    switch (currentState, chars) {
    <span class="ea">| (<span class="da">`FoundBracket(<span class="-W">startIndex</span>)</span>, [')', <span class="-_">...</span><span class="da">_</span>]) =></span>
      <span class="da">Some((<span class="-W">startIndex</span>, <span class="-W">currentIndex</span>)</span>)
    <span class="ea">| (<span class="da">_</span>, ['(', <span class="-_">...</span>tail]) =></span>
      iter(<span class="da">`FoundBracket(<span class="-W">currentIndex</span>)</span>, tail, currentIndex + <span class="-E">1</span>)
    <span class="ea">| (<span class="da">_</span>, [<span class="da">_</span>, <span class="-_">...</span>tail]) =></span>
      iter(currentState, tail, currentIndex + <span class="-E">1</span>)
    <span class="ea">| (<span class="da">_</span>, []) =></span>
      None
    };
  iter(`NoBrackets, inputChars, <span class="-E">0</span>);
};</code></pre><p>In the above example, we could have defined a type just for the iteration state, but with polymorphic variants, we donâ€™t have to.</p><h2>Diving Deeper</h2><p>Unlike when defining the types for regular variants, you can build polymorphic variants using other variants. Other than the backtick for each name, the types for polymorphic variants also need square brackets around them.</p><pre><code class="-M -Z"><span class="-h">type</span> primary = <span class="-o">[ | `R<span class="ca">ed</span> | `G<span class="ca">reen</span> | `B<span class="ca">lue</span>]</span>;
<span class="-h">type</span> colorFunctions = <span class="-o">[ | `R<span class="ca">gb</span>(<span class="ca">int</span>, <span class="ca">int</span>, <span class="ca">int</span>) | `H<span class="ca">sl</span>(<span class="ca">int</span>, <span class="ca">int</span>, <span class="ca">int</span>)]</span>;
<span class="-e">/* Combiles both the variants primary and colorFunctions */</span>
<span class="-h">type</span> colors = <span class="-o">[ <span class="ca">primary</span> | <span class="ca">colorFunctions</span>]</span>;</code></pre><p>Now that our types are a bit more complicated, youâ€™ll want to actually write the type definitions. Youâ€™ll be able to compile without them, but when you do get errors â€” especially with large types â€” the error messages will be multiple pages on your terminal and wonâ€™t help you at all.</p><p>The above example is a common way for articles to demonstrate polymorphic variants. But itâ€™s not a great example â€” this could be a regular variant type, and it might be better that way. So Iâ€™m going to give two examples of cases where polymorphic variants actually helped.</p><h2>Units of Measure</h2><p>When converting between units â€” like meters to inches â€” itâ€™s normally just multiplying by something. However, Celsius and Fahrenheit do their own thing, and need to be handled differently.</p><p>For this example, we want to take a unit and a value, and convert it into standard units (<em>si</em> units). I represent this with polymorphic variants, and have one function that handles all the â€˜niceâ€™ values, and another function that handles the edge cases.</p><pre><code class="-M -Z"><span class="-h">type</span> length = <span class="-o">[ | `M<span class="ca">eter</span> | `I<span class="ca">nch</span>]</span>;
<span class="-h">type</span> time = <span class="-o">[ | `S<span class="ca">econd</span> | `M<span class="ca">inute</span> | `H<span class="ca">our</span>]</span>;
<span class="-h">type</span> temperatureLinear = <span class="-o">[ | `K<span class="ca">elvin</span>]</span>;
<span class="-h">type</span> temperatureNonLinear = <span class="-o">[ | `C<span class="ca">elsius</span>]</span>;

<span class="-h">type</span> unitLinear = <span class="-o">[ <span class="ca">length</span> | <span class="ca">time</span> | <span class="ca">temperatureLinear</span>]</span>;
<span class="-h">type</span> anyUnit = <span class="-o">[ <span class="ca">unitLinear</span> | <span class="ca">temperatureNonLinear</span>]</span>;

<span class="-h">let</span> siScale =<span class="-T"> (<span class="-W">unit</span>: <span class="-W">unitLinear</span>) =></span>
  switch (<span class="-u">unit</span>) {
  <span class="ea">| <span class="da">`Meter</span> =></span> <span class="-E">1.</span>
  <span class="ea">| <span class="da">`Inch</span> =></span> <span class="-E">0.0254</span>
  <span class="ea">| <span class="da">`Second</span> =></span> <span class="-E">1.</span>
  <span class="ea">| <span class="da">`Minute</span> =></span> <span class="-E">60.</span>
  <span class="ea">| <span class="da">`Hour</span> =></span> <span class="-E">3600.</span>
  <span class="ea">| <span class="da">`Kelvin</span> =></span> <span class="-E">1.</span>
  };

<span class="-h">let</span> toSi =<span class="-T"> (<span class="-W">value</span>, <span class="-W">unit</span>: <span class="-W">anyUnit</span>) =></span>
  switch (<span class="-u">unit</span>) {
  <span class="ea">| #<span class="-u">unit</span><span class="da">Linear</span> <span class="-h">as</span> linear<span class="da">Unit</span> =></span> value<span class="-_"> *. </span>si<span class="da">Scale(<span class="-W">linearUnit</span>)</span>
  <span class="ea">| <span class="da">`Celsius</span> =></span> value<span class="-_"> +. </span><span class="-E">273.15</span>
  };</code></pre><blockquote><p>Note: <code>#unitLinear</code> in the means match against all cases in the unitLinear type</p></blockquote><p>With this setup, we can be much more granular about how we handle edge cases.</p><p>If we added another linear unit â€” like feet â€” to this, our compiler would enforce that itâ€™s in the <code>siScale</code> function. If we added Fahrenheit, it would make sure it was handled in the <code>toSi</code> function.</p><p>If we used regular variants, we could put all the units in one variant, but then weâ€™d lose the ability to abstract things out like we did, and the type-checker would not be as helpful. Or weâ€™d be able to keep the abstraction, but introducing more variants: weâ€™d need one variant for all the linear units, one variant for temperature units, and one more to wrap it, like <code>LinearUnit(linearUnit) | TemperatureUnit(temperatureUnit)</code>. The user would then have to give units in this format. ðŸ¤®</p><h2>Mixing Scalars and Vectors</h2><p>Say we have a numeric type thatâ€™s more complicated than a float. Maybe itâ€™s an exact fraction, or a decimal. We can also have vectors built up of that type, and nan types. We want to build a maths library where you can add and subtract anything of these types. Polymorphic variants are also a good fit here!</p><pre><code class="-M -Z"><span class="-h">type</span> scalar = <span class="-o">[ | `F<span class="ca">raction</span>(<span class="ca">int</span>, <span class="ca">int</span>) | `D<span class="ca">ecimal</span>(<span class="ca">float</span>)]</span>;
<span class="-h">type</span> value = <span class="-o">[ <span class="ca">scalar</span> | `V<span class="ca">ector</span>(<span class="ca">list</span>(<span class="ca">scalar</span>)) | `N<span class="ca">aN</span>]</span>;

<span class="-h">let</span> addScalar =<span class="-T"> (<span class="-W">a</span>, <span class="-W">b</span>) =></span>
  switch (a, b) {
  <span class="ea">| (<span class="da">`Fraction(<span class="-W">n1</span>, <span class="-W">d1</span>)</span>, <span class="da">`Fraction(<span class="-W">n2</span>, <span class="-W">d2</span>)</span>) =></span>
    <span class="da">`Fraction((<span class="-W">n1</span> <span class="-_">*</span> <span class="-W">d2</span> + <span class="-W">n2</span> <span class="-_">*</span> <span class="-W">d1</span>, <span class="-W">d1</span> <span class="-_">*</span> <span class="-W">d2</span>)</span>)
  <span class="ea">| (<span class="da">`Fraction(<span class="-W">n</span>, <span class="-W">d</span>)</span>, <span class="da">`Decimal(<span class="-W">f</span>)</span>)
  | (<span class="da">`Decimal(<span class="-W">f</span>)</span>, <span class="da">`Fraction(<span class="-W">n</span>, <span class="-W">d</span>)</span>) =></span>
    <span class="da">`Decimal(<span class="-W">f</span> <span class="-_">*</span>. <span class="-W">float_of_int</span>(<span class="-W">n</span>)</span><span class="-_"> /. </span><span class="-u">float</span><span class="da">_of_int(<span class="-W">d</span>)</span>)
  <span class="ea">| (<span class="da">`Decimal(<span class="-W">f1</span>)</span>, <span class="da">`Decimal(<span class="-W">f2</span>)</span>) =></span>
    <span class="da">`Decimal(<span class="-W">f1</span> <span class="-_">*</span>. <span class="-W">f2</span>)</span>
  };

<span class="-h">let</span> add =<span class="-T"> (<span class="-W">a</span>, <span class="-W">b</span>) =></span>
  switch (a, b) {
  <span class="ea">| (#scalar <span class="-h">as</span> a, #scalar <span class="-h">as</span> b) =></span> add<span class="da">Scalar(<span class="-W">a</span>, <span class="-W">b</span>)</span>
  <span class="ea">| (<span class="da">`Vector(<span class="-W">a</span>)</span>, <span class="da">`Vector(<span class="-W">b</span>)</span>) =></span> <span class="da">`Vector(List.<span class="-W">map2</span>(<span class="-W">addScalar</span>)</span>)
  <span class="ea">| <span class="da">_</span> =></span> `NaN
  };</code></pre><p>In the same manner as the previous examples, we <em>could</em> use regular variants here, but it would be less nice for the same reasons.</p><h2>Performance</h2><p>This power can come at a cost. Normally when you see performance warnings about polymorphic variants, it talks about the performance of switch statements and memory usage. Realistically, these arenâ€™t going to affect you.</p><p>However, there is something to be aware of if youâ€™re compiling to JavaScript <strong>and you have a lot of polymorphic variants in one type</strong>: when running <code>switch</code> over a polymorphic type, the code size is a lot larger than youâ€™d expect.</p><p>If we take the units example, and add over a hundred units, every switch statement over the units was 2kb of JS minified â€” this adds up quickly! I changed this to a regular variant, and each switch statement went down to just over 100â€“200 bytes.</p><p>Again, this will only affect you if your types are huge, and will not affect you at all if your types arenâ€™t huge. If in doubt, read what BuckleScript outputs!</p><h2>Conclusion</h2><p>Polymorphic variants are really cool and you should use them more!</p><span class="f">Published on <time dateTime="2019-11-01T00:00:00.000Z">1st November 2019</time></span></body></html>
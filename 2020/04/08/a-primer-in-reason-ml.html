<!DOCTYPE html><html lang="en"><head><title>A Primer in ReasonML</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><script>document.documentElement.style.setProperty("--e",1/(window.devicePixelRatio||1)+"px");</script><style>@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:normal;font-named-instance:"Regular";src:url(/res/541fae2e.woff2);font-display:fallback}@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:italic;font-named-instance:"Regular";src:url(/res/1517082.woff2);font-display:fallback}*,::after,::before{box-sizing:border-box}*{font-size:calc(var(--f)*var(--g));line-height:calc(var(--h)*var(--g));letter-spacing:calc(var(--i)*var(--g));font-weight:var(--j);--g:calc(
    (var(--k) * 1rem / 16) +
    ((1 - var(--k)) * 1px)
  )}@supports (font-variation-settings:"wght"400){*{font-weight:inherit;font-variation-settings:"wght"var(--j)}}:root{--c:#f97f51;--b:#fc427b;--l:#0652dd;--m:#2771f9;--n:var(--l);--a:#a3cb38;--o:#ed4c67;--d:var(--p);--p:black;--q:white;--r:12px;--s:12px;--k:1}::selection{background:var(--d);color:#fff}body{margin:var(--r) var(--s) 64px;--f:18;font-family:Inter,system-ui,-apple-system,sans-serif;color:var(--p);background:var(--q);--h:26}a{color:var(--d);text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.a{display:flex;padding-top:12px;margin:-12px calc(-1*var(--s)) 48px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}.a::after,.a::before{display:block;content:"";padding-right:var(--s)}.b,.d{flex:none;--j:700}.d{display:block;--f:24;--h:18;--i:-1;text-transform:lowercase;border-top:4px solid;padding:6px 4px 0 0}a.d{color:currentColor;text-decoration:none}.b{margin:0 0 0 24px;--f:6;--h:10;--i:1;--k:0;text-transform:uppercase;width:0}.c{margin-left:auto}.e{flex:none;display:block;margin:10px 24px 0 0;--f:14;--h:18;--j:400}.e:last-child{margin-right:0}@media (prefers-color-scheme:dark){:root{--n:var(--m);--p:white;--q:black}}@media (min-width:768px){:root{--s:64px}}@media (min-width:1024px){:root{--s:128px}}:root{--s:max(12px, (100vw - var(--t)) / 2);--t:800px;--d:var(--o)}h1{margin:48px 0 32px;--f:36;--h:48;--i:-0.8}h2,h3{margin:42px 0 18px}h1,h2{font-weight:700}h2{--f:26;--h:34;--i:-0.3}h3{--f:22;--h:30;--i:-0.18}p{margin:18px 0}a,p>code{word-break:break-all}h3,strong{font-weight:600}ol,ul{margin:24px 0;padding-left:32px;margin-left:calc(-32*min(max(var(--s) - 32px,0px),1px))}li{position:relative;margin:2px 0;list-style:none}li::before{position:absolute;content:var(--u, "ðŸ‘‰");right:calc(100% + 12px)}li[data-bullet]{--u:attr(data-bullet)}blockquote{margin:32px 24px 32px 48px;--f:22;--h:32;font-weight:300;font-style:italic}table{margin:24px;border-collapse:separate;border-spacing:12px 0}thead th{border-bottom:var(--e) solid;--j:600;text-align:left}code,hr{background-color:#f4f4f4}hr{margin:32px calc(-1*var(--s));height:var(--e);border:0}code{font-size:.9em;font-family:monospace;padding:0 3px;border:1px solid #eee;border-radius:6px}pre code{display:block;width:100vw;margin:48px calc(-1*var(--s));padding:18px var(--s);background-color:#fafafa;border:1px solid #f4f4f4;border-width:1px 0;border-radius:0;overflow-x:scroll}video{display:block;max-width:100%;margin:32px auto}iframe{width:calc(var(--v)*1);height:calc(var(--v)*.66);border:1px solid rgba(0,0,0,.1);--v:calc(100vw - 2 * var(--s))}.f,blockquote{color:#9e9e9e}@media (min-width:768px){a,p>code{word-break:initial}}@media (prefers-color-scheme:dark){hr,pre code{background-color:#080808}code{background-color:#111;border-color:#222}pre code{border-color:#111}}.-n,.-p{color:#a0a1a7;font-style:italic}.-e,.-q,.-r{color:#a626a4}.-s,.-t,.-u,.-v,.-w{color:#e45649}.-l{color:#0184bb}.-A,.-B,.-x,.-y,.-z{color:#50a14f}.-C .-D,.-o{color:#c18401}.-E,.-F,.-G,.-H,.-I,.-J,.-K,.-k{color:#986801}.-D,.-L,.-M,.-N,.-O,.-P{color:#4078f2}.-Q{font-style:italic}.-R{font-weight:700}.-N{text-decoration:underline}@media (prefers-color-scheme:dark){.-n,.-p{color:#5c6370;font-style:italic}.-e,.-q,.-r{color:#c678dd}.-s,.-t,.-u,.-v,.-w{color:#e06c75}.-l{color:#56b6c2}.-A,.-B,.-x,.-y,.-z{color:#98c379}.-C .-D,.-o{color:#e6c07b}.-E,.-F,.-G,.-H,.-I,.-J,.-K,.-k{color:#d19a66}.-D,.-L,.-M,.-N,.-O,.-P{color:#61aeee}.-Q{font-style:italic}.-R{font-weight:700}.-N{text-decoration:underline}}</style></head><body><div class="a"><a href="/index" class="d">Jacob<br/>does<br/>code</a><div class="b">Apps</div><a href="/pocket-jam" class="e">Pocket Jam</a><a href="/piano-tabs" class="e">Piano Tabs</a><a href="/technicalc" class="e">TechniCalc</a><a href="/freebies" class="e">Freebies</a><div class="b c">Developement</div><a href="/blog" class="e">Blog</a><a href="https://github.com/jacobp100" class="e">Github</a></div><h1>A Primer in ReasonML</h1>
<p>If youâ€™ve used Reason a little bit, you might have seen <code>string_of_int</code>, <code>string_of_float</code>, or if youâ€™re using Belt, <code>Float.toString</code>.</p>
<p>So the question is â€” why is this necessary? A lot of languages let you do <code>toString</code> without saying the type youâ€™re converting from.</p>
<p>A lot of languages support something called function overloading. Take C# for example,</p>
<pre><code><span class="-f"><span class="-o">string</span> <span class="-D">ToString</span>(<span class="-g"><span class="-o">int</span> x</span>)</span> { <span class="-n">/*...*/</span> }
<span class="-f"><span class="-o">string</span> <span class="-D">ToString</span>(<span class="-g"><span class="-o">float</span> x</span>)</span> { <span class="-n">/*...*/</span> }
</code></pre>
<p>In JavaScript, you can get something to the same effect by using <code>typeof</code> checks.</p>
<p>Most languages, too, support essentially the same thing through object inheritance too. You can have a class <code>Pet</code> with a <code>toString</code> method on it, then make subclasses <code>Dog</code> and <code>Cat</code> which each have their own <code>toString</code> methods.</p>
<p>Reason doesnâ€™t support the first kind of overloading. Functions can only be defined once, and you canâ€™t do <code>typeof</code> checks on what is passed in.</p>
<p>Reason does technically have some concept of classes, but they are rarely used. Itâ€™s best to just not use them.
Itâ€™s because of these reasons there are multiple kinds of <code>+</code> operator â€” including <code>+.</code> for floats, <code>++</code> for strings.</p>
<p>This might initially seem like a significant limitation, but the omission of these features is intentional: these features always have edge cases in any language that includes them.</p>
<h2>Modules</h2>
<p>The most unique part of Reason is its module system. They are much more powerful than classes â€” both for the user, the type checker and the compiler.</p>
<p>Usually, you will make your modules as isolated as possible, and group all the functionality in the module â€” not far off what your average class looks like.</p>
<p>The convention is to have a type <code>t</code> that encompasses all the data a class would have. You also normally have a <code>make</code> function to act as a constructor and/or an <code>empty</code> variable if that makes sense for your module. For example,</p>
<pre><code><span class="-e">module</span> Person = {
  <span class="-e">type</span> t = {name: <span class="-o">string</span>};

  <span class="-e">let</span> make =<span class="-f"> <span class="-g">name</span> =&gt;</span> {name: name};

  <span class="-e">let</span> toString =<span class="-f"> <span class="-g">person</span> =&gt;</span> <span class="-x">&quot;Person :&quot;</span><span class="-j"> ++ </span>person.name;
};

<span class="-e">let</span> person = <span class="-S"><span class="-T"><span class="-m">Person</span>.</span></span>make(<span class="-x">&quot;Bob&quot;</span>);
<span class="-e">let</span> personString = <span class="-S"><span class="-T"><span class="-m">Person</span>.</span></span><span class="-e">to</span><span class="-i">String(<span class="-g">person</span>)</span>;
<span class="-S"><span class="-T"><span class="-m">Js</span>.</span></span>log(personString);

<span class="-n">/* Or */</span>
<span class="-e">let</span> personString = <span class="-S"><span class="-T"><span class="-m">Person</span>.</span>(make(&quot;Bob&quot;)-&gt;toString)</span>;
</code></pre>
<p>I said before this isnâ€™t too far from what an average class looks like. But there is one crucial difference.</p>
<p>In OOP, your data and your functions are forcibly coupled together. Here, however, the grouping is just for the programmer â€” there is nothing actually forcing the type and the two functions together.</p>
<p>OOP tends to suffer from data not being strictly hierarchical. By not coupling the data and functions means that when your data isnâ€™t hierarchical, you have much better tools to organise your code â€” although thatâ€™s another blog post.</p>
<h2>Bonus Time</h2>
<p>As a last bonus, something youâ€™ll see in Belt is defining operators in a module â€” and this is something you can do too!</p>
<pre><code><span class="-e">module</span> Fraction = {
  <span class="-e">type</span> t = {
    num: <span class="-o">int</span>,
    den: <span class="-o">int</span>,
  };

  <span class="-e">let</span> make =<span class="-f"> (<span class="-g">num</span>, <span class="-g">den</span>) =&gt;</span> {num, den};

  <span class="-e">let</span><span class="-f"> (+) = (<span class="-g">a</span>, <span class="-g">b</span>) =&gt;</span> {
    num: a.num<span class="-j"> * </span>b.den + a.den<span class="-j"> * </span>b.num,
    den: a.den<span class="-j"> * </span>b.den,
  };
};

<span class="-e">let</span> fractionSum = <span class="-S"><span class="-T"><span class="-m">Fraction</span>.</span>(make(1, 2) + make(1, 3))</span>;
<span class="-S"><span class="-T"><span class="-m">Js</span>.</span></span>log(fractionSum);
</code></pre>
<p>This is a bit like marmite â€” some people love it, some hate it. It really depends on your project how much youâ€™ll make use of it â€” if at all.</p><span class="f">Published on <time dateTime="2020-04-08T00:00:00.000Z">8th April 2020</time></span></body></html>
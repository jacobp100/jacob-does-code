<!DOCTYPE html><html lang="en"><head><title>CSS Cascade Layers</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><link rel="icon" href="/res/19f82827.png" sizes="16x16" type="image/png"/><link rel="icon" href="/res/eb210940.png" sizes="32x32" type="image/png"/><link rel="apple-touch-icon" href="/res/346f150e.png"/><link rel="apple-touch-icon" sizes="57x57" href="/res/96dcd9a9.png"/><link rel="apple-touch-icon" sizes="72x72" href="/res/cf5ba76d.png"/><link rel="apple-touch-icon" sizes="76x76" href="/res/4ba903c3.png"/><link rel="apple-touch-icon" sizes="114x114" href="/res/a58fed4c.png"/><link rel="apple-touch-icon" sizes="120x120" href="/res/a5e39fa5.png"/><link rel="apple-touch-icon" sizes="152x152" href="/res/ca89aad4.png"/><link rel="apple-touch-icon" sizes="167x167" href="/res/5d37ba5a.png"/><link rel="apple-touch-icon" sizes="180x180" href="/res/f0517911.png"/><script>document.documentElement.style.setProperty("--d",1/(window.devicePixelRatio||1)+"px");</script><style>@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:normal;font-named-instance:"Regular";src:url(/res/541fae2e.woff2);font-display:fallback}@font-face{font-family:Inter;font-weight:100 900;font-display:swap;font-style:italic;font-named-instance:"Regular";src:url(/res/1517082.woff2);font-display:fallback}*,::after,::before{box-sizing:border-box}*{font-size:calc(var(--e)*var(--i));line-height:calc(var(--f)*var(--i));letter-spacing:calc(var(--g)*var(--i));font-weight:var(--h);--i:calc(
    (var(--j) * 1rem / 16) +
      ((1 - var(--j)) * 1px)
  )}@supports (font-variation-settings:"wght"400){*{font-weight:inherit;font-variation-settings:"wght"var(--h)}}:root{--k:#f97f51;--l:#fc427b;--m:#0652dd;--n:#2771f9;--o:var(--m);--a:#ffc312;--b:#5f27cd;--p:#341f97;--c:var(--q);--q:black;--r:white;--s:12px;--t:12px;--j:1}::selection{background:var(--c);color:#fff}body{margin:var(--s) var(--t) 64px;--e:18;font-family:Inter,system-ui,-apple-system,sans-serif;color:var(--q);background:var(--r);--f:26}a{color:var(--c);text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.a{display:flex;padding-top:12px;margin:-12px calc(-1*var(--t)) 48px;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch}.a::after,.a::before{display:block;content:"";padding-right:var(--t)}.b,.d{flex:none;--h:700}.d{display:block;--e:24;--f:18;--g:-1;text-transform:lowercase;border-top:4px solid;padding:6px 4px 0 0}a.d{color:currentColor;text-decoration:none}.b{margin:0 0 0 24px;--e:6;--f:10;--g:1;--j:0;text-transform:uppercase;width:0;overflow-wrap:normal}.c{margin-left:auto}.e{flex:none;display:block;margin:10px 24px 0 0;--e:14;--f:18;--h:400}.e:last-child{margin-right:0}@media (prefers-color-scheme:dark){:root{--o:var(--n);--q:white;--r:black}}@media (min-width:768px){:root{--t:64px}}@media (min-width:1024px){:root{--t:128px}}*{overflow-wrap:break-word}:root{--t:max(12px, (100vw - var(--u)) / 2);--u:800px;--c:var(--p)}h1{margin:48px 0 32px;--e:36;--f:48;--g:-0.8}h2,h3{margin:42px 0 18px}h1,h2{font-weight:700}h2{--e:26;--f:34;--g:-0.3}h3{--e:22;--f:30;--g:-0.18}p{margin:18px 0}h3,strong{font-weight:600}ol,ul{margin:24px 0;padding-left:32px;margin-left:calc(-32*min(max(var(--t) - 32px,0px),1px))}li{position:relative;margin:2px 0;list-style:none}li::before{position:absolute;content:var(--v, "ðŸ‘‰");right:calc(100% + 12px)}li[data-bullet]{--v:attr(data-bullet)}blockquote{margin:32px 24px 32px 48px;--e:22;--f:32;font-weight:300;font-style:italic}table{margin:24px;border-collapse:separate;border-spacing:12px 0}thead th{border-bottom:var(--d) solid;--h:600;text-align:left}code,hr{background-color:#f4f4f4}hr{margin:32px calc(-1*var(--t));height:var(--d);border:0}code{font-size:.9em;font-family:monospace;padding:0 3px;border:1px solid #eee;border-radius:6px}pre code{display:block;width:100vw;margin:48px calc(-1*var(--t));padding:18px var(--t);background-color:#fafafa;border:1px solid #f4f4f4;border-width:1px 0;border-radius:0;overflow-x:scroll}video{display:block;max-width:100%;margin:32px auto}iframe{width:calc(var(--w)*1);height:calc(var(--w)*.66);border:1px solid rgba(0,0,0,.1);--w:calc(100vw - 2 * var(--t))}.f,blockquote{color:#9e9e9e}@media (min-width:768px){a,p>code{word-break:initial}}@media (prefers-color-scheme:dark){hr,pre code{background-color:#080808}code{background-color:#111;border-color:#222}pre code{border-color:#111}}.-k,.-m{color:#a0a1a7;font-style:italic}.-b,.-n,.-o{color:#a626a4}.-p,.-q,.-r,.-s,.-t{color:#e45649}.-i{color:#0184bb}.-u,.-v,.-w,.-x,.-y{color:#50a14f}.-l,.-z .-A{color:#c18401}.-B,.-C,.-D,.-E,.-F,.-G,.-H,.-h{color:#986801}.-A,.-I,.-J,.-K,.-L,.-M{color:#4078f2}.-N{font-style:italic}.-O{font-weight:700}.-K{text-decoration:underline}@media (prefers-color-scheme:dark){.-k,.-m{color:#5c6370;font-style:italic}.-b,.-n,.-o{color:#c678dd}.-p,.-q,.-r,.-s,.-t{color:#e06c75}.-i{color:#56b6c2}.-u,.-v,.-w,.-x,.-y{color:#98c379}.-l,.-z .-A{color:#e6c07b}.-B,.-C,.-D,.-E,.-F,.-G,.-H,.-h{color:#d19a66}.-A,.-I,.-J,.-K,.-L,.-M{color:#61aeee}.-N{font-style:italic}.-O{font-weight:700}.-K{text-decoration:underline}}</style></head><body><div class="a"><a href="/" class="d">Jacob<br/>does<br/>code</a><div class="b">Apps</div><a href="/pocket-jam" class="e">Pocket Jam</a><a href="/piano-tabs" class="e">Piano Tabs</a><a href="/technicalc" class="e">TechniCalc</a><a href="/calipers" class="e">Calipers</a><a href="/freebies" class="e">Freebies</a><div class="b c">Developement</div><a href="/blog" class="e">Blog</a><a href="https://github.com/jacobp100" class="e">Github</a></div><h1>CSS Cascade Layers</h1>
<p>CSS just got a new feature: <em>cascade layers</em>. Things are a bit weird now: typically features are implemented (at least in part) by browsers before it makes its way to being fully finalised in the CSS specification as a candidate recommendation. However, at the time of writing, CSS Cascade layers <em>are</em> finalised, but every browser has put them behind feature flags â€” so you canâ€™t actually use them right now.</p>
<p>So what are cascade layers?</p>
<p>If youâ€™ve written enough CSS, youâ€™ll know rules can conflict, and can lead to unexpected bugs. This is beacause every rule has a specificity attached to it, and the ones with larger specificities will win out.</p>
<p>If youâ€™re unfamiliar with how specificity works, take any CSS selector, split it into the parts, then add up all the points using the following chart.</p>
<table><thead><td>Type</td>
<td>Points</td></thead><tbody><tr><td><code>#id</code></td>
<td>100</td></tr><tr><td><code>.class</code></td>
<td>10</td></tr><tr><td><code>[attribute]</code>, <code>[attribute=value]</code> etc.</td>
<td>10</td></tr><tr><td><code>:first-child</code>, <code>:last-child</code> etc.</td>
<td>10</td></tr><tr><td><code>tagname</code> (e.g. <code>p</code>, <code>div</code> etc.)</td>
<td>1</td></tr><tr><td><code>*</code></td>
<td>0</td></tr><tr><td><code>:not(selector)</code>, <code>:matches(selector)</code></td>
<td>Specificity of inner selector</td></tr></tbody></table>

<p>So the selector <code>button.primary</code> has a specificity of <code>011</code>, <code>button:hover</code> also has <code>011</code>, and <code>button.primary.small</code> has <code>021</code> â€” so will win over the previous two.</p>
<hr/>
<p>Something not a lot of people know is the styles applied by the browser are done via CSS â€” but they will <strong>never</strong> win over your styles. They could use all the <code>#id</code> selectors they want, and your <code>*</code> selector will still win.</p>
<p>Cascade layers are an extension of this concept. Youâ€™ll be able to define your own layers and their order. Later layers will always override styles of previous layers, regardless of specificities.</p>
<p>Imagine you have a CSS reset, and you want to put your styles over the top. This is what it will look like using cascade layers:</p>
<pre><code><span class="-b">@layer</span> reset {
  <span class="-r">button</span><span class="-H">:not</span>(<span class="-G">[disabled]</span>) {
    <span class="-x">color</span>: black;
  }
}

<span class="-b">@layer</span> styles {
  <span class="-r">button</span> {
    <span class="-x">color</span>: red;
  }
}
</code></pre>
<p>The selector in the reset had a specificity of <code>021</code>, and the one in styles had <code>001</code>. Using cascade layers, we can guarantee that the button text will be <code>red</code>.</p>
<p>Layers apply in the order they first occur. Redefining a layer doesnâ€™t change the order, and styles will be merged into it. Styles outside a layer will beat all styles inside layers.</p>
<p>Interestingly, for styles containing <code>!important</code>, the exact opposite is true. The first layer with style containing <code>!imporant</code> will always win over later layers that have matching styles with <code>!important</code>. Styles outside a layer containing <code>!important</code> will always be overridden by the first layer with a matching styles with <code>!important</code>.</p>
<p>You can define a layer with no styles to predefine the ordering, then add the styles to the layers late:</p>
<pre><code><span class="-b">@layer</span> reset, styles;

<span class="-b">@layer</span> styles {
  <span class="-k">/* Styles */</span>
}

<span class="-b">@layer</span> reset {
  <span class="-k">/* Styles */</span>
}
</code></pre>
<p>Layers can be nested:</p>
<pre><code><span class="-b">@layer</span> framework {
  <span class="-b">@layer</span> layout {
    <span class="-k">/* Styles */</span>
  }
}

<span class="-k">/* Or */</span>

<span class="-b">@layer</span> framework.layout {
  <span class="-k">/* Styles */</span>
}
</code></pre>
<p>Media queries work within layers, and layers work media queries â€” you can do it both ways, it really doesnâ€™t matter.</p>
<pre><code><span class="-b">@media</span> screen {
  <span class="-b">@layer</span> styles {
    <span class="-k">/* Styles */</span>
  }
}

<span class="-k">/* Or */</span>

<span class="-b">@layer</span> styles {
  <span class="-b">@media</span> screen {
    <span class="-k">/* Styles */</span>
  }
}
</code></pre>
<p>And lastly, thereâ€™s a new <code>revert-layer</code> value for any property, which will revert any styles youâ€™ve defined in the current layer to the styles defined in the previous layers.</p>
<pre><code><span class="-b">@layer</span> styles {
  <span class="-r">button</span> {
    <span class="-x">color</span>: red;
  }

  <span class="-r">button</span><span class="-G">[disabled]</span> {
    <span class="-k">/* Whatever was previously defined outside of the styles layer */</span>
    <span class="-x">color</span>: revert-layer;
  }
}
</code></pre>
<h2>Use in Practise</h2>
<p>Itâ€™s hard to comment on how to use this in practise: itâ€™s so new itâ€™s not possible to use for a production website. It will take some time for people to figure out what works well and what doesnâ€™t.</p>
<p>However, it is pretty likely youâ€™ll have a split of CSS resets or normalization, some framework CSS, then your overrides.</p>
<p>And for this case, cascade layers definitely arenâ€™t a silver bullet. You will still have to consider the selectors applied on other layers. Take a button in a framework we want to modify:</p>
<pre><code><span class="-b">@layer</span> framework {
  <span class="-r">button</span> {
    <span class="-x">background</span>: <span class="-l">var</span>(--blue);
  }

  <span class="-r">button</span><span class="-H">:hover</span> {
    <span class="-x">background</span>: <span class="-l">var</span>(--light-blue);
  }

  <span class="-r">button</span><span class="-H">:focus</span>,
  <span class="-r">button</span><span class="-H">:active</span> {
    <span class="-x">background</span>: <span class="-l">var</span>(--dark-blue);
  }
}

<span class="-b">@layer</span> overrides {
  <span class="-r">button</span> {
    <span class="-x">background</span>: <span class="-l">var</span>(--red);
  }
}
</code></pre>
<p>With or without cascade layers, we have a bug. Without cascade layers, the <code>hover</code>, <code>focus</code>, and <code>active</code> states are the wrong colour. With cascade layers, we donâ€™t have those states.</p>
<p>The former â€” while incorrect â€” was more accessible than what we have now.</p>
<p>You could have other selectors that are less obvious they may need be applied: things like <code>:first-child</code> or other conditions that are only relevant to your framework. These could be more subtle bugs â€” and they would probably be easier to find if youâ€™re not using cascade layers.</p>
<h2>Styled Components</h2>
<p>Styled Components used to advertise it fixes specificity issues. That looks to have been taken out of their elevator pitch, and thatâ€™s probably because in the docs, it recommends using a good measure of <code>&amp;</code> selectors when things donâ€™t work, and keep adding them until things do work. This works because the <code>&amp;</code> selector ends up having the same specificity as a class â€” and if it feels like a hackâ€¦ Itâ€™s because it is.</p>
<p>Cascade layers would be a great way to fix this issue. Youâ€™d dynamically generate a new layer for each component, then generate additional cascade layers when extending component styles, so your extended styles will always win.</p>
<p>This isnâ€™t perfect â€” you still have the exact same issue from the previous section. Since specificity issues show up a lot, it would probably make sense for Styled Components to use cascade layers as described here.</p>
<h2>Closing Thoughts</h2>
<p>This is quite a nice and well thought-out addition. It doesnâ€™t radically change CSS, but it provides some new ways to organise things. I imagine it will remove some unexpected bugs when working with CSS â€” especially with frameworks, but will, of course, introduce new surprises â€” (although hopefully fewer).</p>
<p>Itâ€™ll be some time until youâ€™re able to use it in production natively, but it is probably possible today to make a postCSS plugin to automatically add specificity hacks to make layers work without actually using layers for backwards compatibility.</p>
<p>The ordering of layers being when <code>!important</code> is involved is surprising to say the least â€” and I donâ€™t think Iâ€™m the only one who will think this. In practical terms, it means you canâ€™t use it anything but overrides (for better or worse), because youâ€™ll never be able to redefine it with overrides.</p>
<p>This decision was probably taken to be consistent with other parts of CSS: it copies the behaviour how the browserâ€™s internal CSS styles handle <code>!important</code>. The specification wanted to ensure that a website would never be able to override any browser styles marked a <code>!imporant</code>. However, no browser has done this in decades â€” if ever.</p>
<p>This odd behaviour actually dates back to when CSS was created, and the expectation was users, browsers, and publishers would all be writing their own styles for one website, and the end result would be a mix of all these styles.</p>
<p>As it turns out, users of a website did not end up writing CSS for that website (shocking, I know), and browsers only provide a very minimal set of defaults that are always overridable. My take is it would have probably been better to draw a line under idea of multiple parties deciding the styling of a website, accept it will make the CSS specification margnially less consistent for the few who read it, but have cascade layers behave more predictably. Time will tell on this one.</p><span class="f">Published on <time dateTime="2021-12-04T00:00:00.000Z">4th December 2021</time></span></body></html>